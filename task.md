# Задание 2. Singleton
В этом разделе описан класс Logger (ru.npcric.asparagus.trainerslog.service.logger), который реализует паттерн проектирования Singleton

## Причины выбора Singleton для класса Logger
1. Единая точка доступа:
Singleton гарантирует, что в приложении будет только один экземпляр Logger. Это упрощает управление доступом к логированию и предотвращает создание нескольких логгеров, которые могли бы конфликтовать друг с другом. 

2. Экономия ресурсов:
Создание множества экземпляров логгера может привести к избыточному потреблению ресурсов, особенно если логгер управляет подключениями к файловой системе или сетевым ресурсам. Singleton помогает избежать этого.

3. Удобство:
Реализация Logger с помощью Singleton гарантирует, что все логи будут записываться в одно место


## Признаки реализации Singleton в классе Logger
1. Приватный конструктор

2. Статическое поле для хранения экземпляра
  
3. Статический метод для доступа к экземпляру

Реализация класса Logger

```
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

//Реализация паттерна Singleton
public class Logger {
    private static Logger instance;
    private static final String LOG_FILE_PATH = "application.log"; // Путь к файлу лога


    private Logger() {
    }

    // Метод для получения единственного экземпляра
    public static synchronized Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }

    // Метод для записи сообщений в лог
    public void log(String message) {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        String logMessage = String.format("%s: %s%n", timestamp, message);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            writer.write(logMessage);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```


(Забыл на прошлой неделе обновить task.md файл для заданий 3 и 4, но коммиты были отправлены во время, ссылка на коммиты
https://github.com/flashouti/trainerslog/commit/15a4a13909110b04fe859cc91663f7e984fdb1df
https://github.com/flashouti/trainerslog/commit/49fd7ba4fdf761fda435c92dcc259f57199a6658)

# Задание 3. Prototype
(ru.npcric.asparagus.trainerslog.adapter.web.dto.request.filial)

## Причины выбора паттерна Prototype для класса FilialDTO
1. Упрощение создания объектов: Паттерн Prototype позволяет создавать новые объекты, копируя существующие. В нашем случае будет создавать много объектов класса FilialDTO
2. Избежание избыточного кода: Вместо повторного написания кода для инициализации новых объектов с одинаковыми значениями, мы можем просто использовать метод clone(), что делает код более чистым и понятным.
3. Изменяемость и гибкость: Если в будущем потребуется изменить структуру класса (например, добавить новые поля), достаточно будет обновить метод clone()

## Признаки реализации паттерна Singleton
1.  Метод clone(): Этот метод создает новый экземпляр FilialDTO, копируя значения полей из текущего объекта


# Задание 4. Static factory method 

## Причины выбора паттерна SFM для класса FilialEntity  
(ru.npcric.asparagus.trainerslog.domain)

1. Частое создание экзампляра с заданными полями (дефолтным именем для всех филлиалов, различаются только адреса) - удобно вынести в отдельный метод
2. Читаемость и гибкость кода

## Признаки реализации паттерна SFM
1. Приватный когнструктор класса FilialEntity
2. static метод getFilialWithDefaultName, возвращающий объект класса FilialEntity с определнными полями 


# Задание 5. Реализация паттерна Builder 
Реализовал паттерн Builder для класса TicketEntity в классе TicketBuilder в пакете ru.npcric.asparagus.trainerslog.domain

## Причины выбора паттерна Builder для класса TicketEntity
1. Есть вариация создания объектов с разными наборами полей - при реализации паттерна код становится более гибкий
2. Читаемость кода, сложная структура класса при использовании buildera воспринимается понятнее

## Признаки реализации 

1. В классе TicketBuilder дублируются все поля класса TicketEntity
2. В классе TicketBuilder методы назначают поля текущему объекту и возвращают объект
3. В классе TicketBuilder есть метод build() который возращает объект с назначенными полями
4. В классе TicketEntity есть метод builder(), который возращает новый объект класса TicketBuilder


# Задание 7. Реализация паттерна Abstract Factory
Реализовал паттерн Abstract Factory в классе BaseFactory в пакете ru.npcric.asparagus.trainerslog.service.factory.common

## Признаки реализации паттерна Abstract Factory для класса Base Factory
1. Абстрактный продукт - BaseContext
2. Конкретные продукты - CoachContext, StudentContext, FilialContext. Реализуют интерфейс BaseContext
3.  Абстрактная фабрика - BaseFactory, абстраный метод - createContext()
4.  Конкретная фабрика - CoachFactory, StudentFactory, FilialFactory. Они реализуют метод createContext()
5.  Использование - в сервисах

# Задание 8. Реализация паттерна Adapter
Реализовал паттерн Adapter в классе LoggerAdapter в пакете ru.npcric.asparagus.trainerslog.service.logger

## Причины реализации 
1. Есть удобный интерфейс MyLogger, который имеет понятные по названию методы и класс Logger из пакета java.util.logging, названия методов которые не расскрывают полностью назначение методов - в качестве удобства раелизовал класс LoggerAdapter

## Признаки 
1. LoggerAdapter реализует интерфейс MyLogger, с классом Logger используется связь композиция  - объект класса инициализируется в конструкторе
2. В методах адаптера совмещается логика двух классов


# Задание 9. Реализация паттерна Bridge
Реализовал паттерн Bridge в классе Notification в пакете package ru.npcric.asparagus.trainerslog.service.notification;

## Причины реализации
1. Количество классов наследников от классов Notification и MessageSender может быстро расти а вместе с тем и их "комбинации"

## Признаки реализации 
1. Классы родители (Notification и MessageSender) и их наследники, количество которых может быстро расти
2. В классе Notification использутеся связь композиция с классом MessageSender (разбиение иерархии на две независимых)

# Задание 10. Реализация паттерна Composite
Реализовал паттерн Composite в классе DocumentComponent в пакете ru.npcric.asparagus.trainerslog.service.document;

## Причины реализации
1. У нас есть система управления документами, где документы могут содержать как текстовые блоки, так и другие документы. 
При этом текстовые блоки не могут содержать документы иои другие текстовые блоки. Для представления этой структуры подходит древовидная структура,
которую можно реализовать используя паттерн Composite

## Признаки реализации 
1. Классы Document и TextBlock реализуют один интерфейс DocumentComponent 
2. Класс Document при этом является узлом в древовидной структуре, так как имеет поле со списком дочерних объектов DocumentComponent,
а также методы по добавлению и удалению объекта DocumentComponent из списка
3. Класс TextBlock при этом является листом в древовидной структуре, так как не имеет поля со списком объектов DocumentComponent,
а в реализации методов addComponent() и removeComponent() выбрасывается исключение 


# Задание 11. Реализация паттерна Decorator
Реализовал паттерн Decorator в классе TextDecorator в пакете ru.npcric.asparagus.trainerslog.service.document.textcontent;

## Причины реализации
1. У нас есть текст в текстовых блоках, у которого может быть определенный шрифт
используя паттерн Decorator, мы смогли динамически добавлять различные стили к тексту, не изменяя его основной структуры. Это делает систему более гибкой и позволяет легко комбинировать различные стили

## Признаки реализации
1. Класс TextDecorator одновременно реализует интерфейс Text и содержит его экземпляр в виде поля
2. Существуют конкретные декораторы, которые наследуются от класса TextDecorator - BoldTextDecorator, ItalicTextDecorator, UnderLineTextDecorator
которые расширяют функционал компонента, переопределяя метод getContent(), добавляя дополнительную логику

## Задание 12. Реализация паттерна Facade
Паттерн Facade был реализован в классе SecurityConfig в методе filterChain()

## Признаки реализации
1. Паттерн Facade предоставляет упрощённый интерфейс для сложной системы. В данном случае метод filterChain служит фасадом для настройки безопасности в приложении, скрывая детали конфигурации HttpSecurity
2. Метод filterChain инкапсулирует множество вызовов методов, связанных с настройкой безопасности (например, CORS, CSRF, аутентификация и авторизация)
3. Фасад взаимодействует с несколькими подсистемами (например, CORS, CSRF, аутентификация), но предоставляет единую точку доступа для конфигурации


## Задание 14
Реализовал паттерн Proxy в классе FilialServiceProxy в пакете ru.npcric.asparagus.trainerslog.service.filial

## Признаки реализации
1. Классы FilialService и FilialServiceProxy реализуют один интерфейс FilialServiceInterface
2. Класс FilialServiceProxy содержит экземпляр класса FilialService и использует его для вызова реализации метода родителя в своих методах
3. Метод getAll реализует сам FilialServiceProxy


## Задание 15
Реализовал паттерн COR в классе Logger в пакете ru.npcric.asparagus.trainerslog.service.logger

## Признаки реализации
1. Есть абстрактный класс Logger, который является обработчиком, содержит ссылку на следующий обработчик
2. Конкретные обработчики - ConsoleLogger, FileLogger, LoggerChain, наследуются от абстрактного класса Logger
3. Все конкретные обработчики реализуют хранение и вызов следующего обработчика 
4. Существует вспомогательный класс LoggerChain - использующийся для хранения нашей цепочки 

## Задание 16
Реализовал паттерн Command в классе Command в пакете ru.npcric.asparagus.trainerslog.service.task;

## Признаки реализации
1. Интерфейс Command содержит метод execute(). Этот интерфейс реализуют конкретные команды - классы AddTaskCommand и RemoveTaskCommand,
которые переопределяют метод execute(), в котором вызывается методы класса TaskManager
2. Класс TaskManager, который является исполнителем команд
3. Класс Invoker принимает команды и вызывает их метод execute(). Он управляет выполнением команд и может хранить историю выполненных команд
4. Отсутствие прямой зависимости между инициатором и обработчиком


## Задание 17
Реализовал паттерн Interpreter в классе Expression

## Признаки реализации
1.  Наличие общего интерфейса Expression, который определяет метод interpret()
2. Конкретные реализации интерфейса Expression NumberExpression, AdditionExpression, SubstractionExpression
3. Использование стека для построения дерева выражений. Каждый узел дерева представляет собой выражение, и дочерние узлы представляют подвыражения
4. Использование рекурсивного подхода для вычисления значения выражения. Каждый класс выражения может вызывать метод interpret() своих дочерних узлов


## Задание 18
Реализовал паттерн Iterator в интерфейсе Iterator в пакете ru.npcric.asparagus.trainerslog.service.iterator

## Признаки реализации 
1. Итератор - интерфейс Iterator реализуется в конкретном итераторе - MyIterator и содержит поле класса DoublyLinkedList, который является агрегатом 
Существует связь между с агрегатом
2. Отделение логики итерации от коллекции. Логика итерации вынесена в отдельный класс (итератор), что позволяет скрыть внутреннюю структуру коллекции от пользователя
3. MyIterator реализует метод next() для доступа к элементам MyCollection по одному


## Задание 19
Реализовал паттерн Mediator в интерфейсе ChatMediator в пакете ru.npcric.asparagus.trainerslog.service.chat

## Признаки реализации 
1. Централизованное управление взаимодействием: Все коммуникации между компонентами (конкретный коллега в данном случае ChatUser наследуется от коллеги User) 
происходят через один объект-посредник (конкретный медиатор ChatRoom), который управляет этими взаимодействиями
2. Компоненты не знают о других компонентах напрямую. Вместо этого они взаимодействуют с посредником


## Задание 20
Реализовал паттерн Memento в классе Document.Memento в пакете ru.npcric.asparagus.trainerslog.service.document

## Признаки реализации 
1. Класс Document содержит внутренний класс Memento, который дублирует поля класса Document
2. В классе Document есть метод save(), который возвращает новый объект класса Memento, который копирует в себе состояние исходного объекта Document,'
у которого вызывается данный метод  и метод restore(), который назначает поля текущему объекту Document из передаваемого объекта Memento
3. Существует посыльник DocumentManager, который хранит в себе мапу для хранения объектов класса Memento, а также содержит методы save() для
сохранения нового объекта Memento по текущему объекта Document


## Задание 21
Реализовал паттерн Observer в интерфейсе Observer в пакете ru.npcric.asparagus.trainerslog.service.observer;

## Признаки реализации 
1. Субъект (Subject)

   • Объект, который содержит состояние и управляет списком наблюдателей.

   • Предоставляет методы для добавления, удаления и уведомления наблюдателей.

2. Наблюдатель (Observer)

• Интерфейс или абстрактный класс, который определяет метод update(), который будет вызываться при изменении состояния субъекта.

• Конкретные классы наблюдателей реализуют этот интерфейс для обработки уведомлений.
Уведомление Наблюдателей

3. При изменении состояния субъекта вызывается метод notifyObservers(), который проходит по списку наблюдателей и вызывает их метод update().


## Задание 22
Реализовал паттерн State в интерфейсе OrderState в пакете ru.npcric.asparagus.trainerslog.service.order;

## Признаки реализации 
1. Интерфейс OrderState - абстрактное состояние 
2. Классы CanceledOrderState, CompletedOrderState, InProgressOrderState, NewOrderState - конкретные состояния, реализующие интерфейс OrderState
3. Контекстом является класс Order, где существуют методы по получению определнного состояния и их изменения


## Задание 23
Реализовал паттерн Strategy в интерфейсе PaymentStrategy в пакете ru.npcric.asparagus.trainerslog.service.strategy

## Признаки реализации 
1. Определяется общий интерфейс PaymentStrategy для всех поддерживаемых алгоритмов (стратегий). Этот интерфейс позволяет клиентам взаимодействовать с различными стратегиями через единый контракт
2. Реализуются конкретные классы (CreditCardPayment, PayPalPayment), которые реализуют интерфейс стратегии. Каждая стратегия инкапсулирует конкретный алгоритм или поведение
3.  Создается класс контекста, который использует ссылку на интерфейс стратегии. Контекст делегирует выполнение алгоритма текущей стратегии


## Задание 24
Реализовал паттерн Template Method в классе ApiRequestHandler в пакете ru.npcric.asparagus.trainerslog.service.requestHandler

## Признаки реализации 
1. В базовом классе ApiRequestHandler есть неизменяемый метод handleRequest(), который вызывает примитивные методы processRequest(),
authenticate() и sendResponse()
2. В классах GetRequestHandler и PostRequestHandler переопределяются примитивные методы processRequest() и sendResponse()
3. При этом не изменяется базовый метод, в нем сохраняется порядок вызова примитивных методов



